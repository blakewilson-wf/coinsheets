/* 
 * Workiva Developer API
 *
 * APIs provided for 3rd party integrations. Build: c0ca649
 *
 * OpenAPI spec version: 0.1.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package swagger

import (
	"net/url"
	"encoding/json"
	"fmt"
	"strings"
)

type SpreadsheetsApi struct {
	Configuration Configuration
}

func NewSpreadsheetsApi() *SpreadsheetsApi {
	configuration := NewConfiguration()
	return &SpreadsheetsApi{
		Configuration: *configuration,
	}
}

func NewSpreadsheetsApiWithBasePath(basePath string) *SpreadsheetsApi {
	configuration := NewConfiguration()
	configuration.BasePath = basePath

	return &SpreadsheetsApi{
		Configuration: *configuration,
	}
}

/**
 * Create a new spreadsheet.
 *
 * @param spreadsheetBodyParameter Properties for creating a new spreadsheet
 * @param xApiKey API callers are identified by API keys. Throttling and request quota limits are set for each individual API key.  
 * @return *SpreadsheetResponse
 */
func (a SpreadsheetsApi) SpreadsheetsPost(spreadsheetBodyParameter SpreadsheetBody, xApiKey string) (*SpreadsheetResponse, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.Configuration.BasePath + "/spreadsheets"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(oauth)' required
	// oauth required
	if a.Configuration.AccessToken != ""{
		headerParams["Authorization"] =  "Bearer " + a.Configuration.AccessToken
	}
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Api-Key"
	headerParams["X-Api-Key"] = xApiKey

	// body params
	postBody = &spreadsheetBodyParameter

	var successPayload = new(SpreadsheetResponse)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Delete a Spreadsheet
 * Deletes an existing spreadsheet. 
 *
 * @param spreadsheetId A unique identifier for a spreadsheet
 * @param xApiKey API callers are identified by API keys. Throttling and request quota limits are set for each individual API key.  
 * @return *EmptyResponse
 */
func (a SpreadsheetsApi) SpreadsheetsSpreadsheetIdDelete(spreadsheetId string, xApiKey string) (*EmptyResponse, *APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.Configuration.BasePath + "/spreadsheets/{SpreadsheetId}"
	path = strings.Replace(path, "{"+"SpreadsheetId"+"}", fmt.Sprintf("%v", spreadsheetId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(oauth)' required
	// oauth required
	if a.Configuration.AccessToken != ""{
		headerParams["Authorization"] =  "Bearer " + a.Configuration.AccessToken
	}
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Api-Key"
	headerParams["X-Api-Key"] = xApiKey

	var successPayload = new(EmptyResponse)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Retrieve a Spreadsheet
 * Gets an existing spreadsheet given a spreadsheet id.
 *
 * @param spreadsheetId A unique identifier for a spreadsheet
 * @param xApiKey API callers are identified by API keys. Throttling and request quota limits are set for each individual API key.  
 * @param revision The Spreadsheet revision from which to select data. If no revision is  provided, the latest revision will be selected. 
 * @return *SpreadsheetResponse
 */
func (a SpreadsheetsApi) SpreadsheetsSpreadsheetIdGet(spreadsheetId string, xApiKey string, revision int32) (*SpreadsheetResponse, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/spreadsheets/{SpreadsheetId}"
	path = strings.Replace(path, "{"+"SpreadsheetId"+"}", fmt.Sprintf("%v", spreadsheetId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(oauth)' required
	// oauth required
	if a.Configuration.AccessToken != ""{
		headerParams["Authorization"] =  "Bearer " + a.Configuration.AccessToken
	}
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("revision", a.Configuration.APIClient.ParameterToString(revision, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Api-Key"
	headerParams["X-Api-Key"] = xApiKey

	var successPayload = new(SpreadsheetResponse)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Update a Spreadsheet
 * Updates a Spreadsheet using the given Spreadsheet properties. If any  property is null or not included in the request the property will not  be modified. 
 *
 * @param spreadsheetId A unique identifier for a spreadsheet
 * @param spreadsheetBodyParameter Properties for creating a new spreadsheet
 * @param xApiKey API callers are identified by API keys. Throttling and request quota limits are set for each individual API key.  
 * @return *EmptyResponse
 */
func (a SpreadsheetsApi) SpreadsheetsSpreadsheetIdPut(spreadsheetId string, spreadsheetBodyParameter SpreadsheetBody, xApiKey string) (*EmptyResponse, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.Configuration.BasePath + "/spreadsheets/{SpreadsheetId}"
	path = strings.Replace(path, "{"+"SpreadsheetId"+"}", fmt.Sprintf("%v", spreadsheetId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(oauth)' required
	// oauth required
	if a.Configuration.AccessToken != ""{
		headerParams["Authorization"] =  "Bearer " + a.Configuration.AccessToken
	}
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Api-Key"
	headerParams["X-Api-Key"] = xApiKey

	// body params
	postBody = &spreadsheetBodyParameter

	var successPayload = new(EmptyResponse)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Get a list of sheets
 * Retrieves all Sheets in the outline
 *
 * @param spreadsheetId A unique identifier for a spreadsheet
 * @param xApiKey API callers are identified by API keys. Throttling and request quota limits are set for each individual API key.  
 * @param revision The Spreadsheet revision from which to select data. If no revision is  provided, the latest revision will be selected. 
 * @return *SheetsResponse
 */
func (a SpreadsheetsApi) SpreadsheetsSpreadsheetIdSheetsGet(spreadsheetId string, xApiKey string, revision int32) (*SheetsResponse, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/spreadsheets/{SpreadsheetId}/sheets"
	path = strings.Replace(path, "{"+"SpreadsheetId"+"}", fmt.Sprintf("%v", spreadsheetId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(oauth)' required
	// oauth required
	if a.Configuration.AccessToken != ""{
		headerParams["Authorization"] =  "Bearer " + a.Configuration.AccessToken
	}
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("revision", a.Configuration.APIClient.ParameterToString(revision, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Api-Key"
	headerParams["X-Api-Key"] = xApiKey

	var successPayload = new(SheetsResponse)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Creates a new Sheet
 * Creates a new sheet within the current spreadsheet.
 *
 * @param spreadsheetId A unique identifier for a spreadsheet
 * @param sheetBodyParameter Properties for creating a new sheet
 * @param xApiKey API callers are identified by API keys. Throttling and request quota limits are set for each individual API key.  
 * @return *SheetResponse
 */
func (a SpreadsheetsApi) SpreadsheetsSpreadsheetIdSheetsPost(spreadsheetId string, sheetBodyParameter SheetBody, xApiKey string) (*SheetResponse, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.Configuration.BasePath + "/spreadsheets/{SpreadsheetId}/sheets"
	path = strings.Replace(path, "{"+"SpreadsheetId"+"}", fmt.Sprintf("%v", spreadsheetId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(oauth)' required
	// oauth required
	if a.Configuration.AccessToken != ""{
		headerParams["Authorization"] =  "Bearer " + a.Configuration.AccessToken
	}
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Api-Key"
	headerParams["X-Api-Key"] = xApiKey

	// body params
	postBody = &sheetBodyParameter

	var successPayload = new(SheetResponse)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Retrieves data in a Region
 * Retrieves all data in a region, paging if necessary.   When paging, the revision parameter must be set and the per_page parameter indicates the  maximum number of cells to include in a single response. The server enforces a maximum  per_page of 50,000. An unbounded region may only be used to obtain the first page of  results. Use the paged_region or next_url from the first page to retrieve  subsequent pages. All cells in the requested region will appear exactly once during the  paging process, however ordering is not guaranteed. 
 *
 * @param spreadsheetId A unique identifier for a spreadsheet
 * @param sheetId A unique identifier for a sheet within a spreadsheet
 * @param xApiKey API callers are identified by API keys. Throttling and request quota limits are set for each individual API key.  
 * @param revision The Spreadsheet revision from which to select data. If no revision is  provided, the latest revision will be selected. 
 * @param region A1 style representation of a Cell or Range. The Range may be unbounded in  any/all directions.  For example: * The (entirely bounded) Range \&quot;A2:D8\&quot; will select all data in the Range between A2 and D8 (inclusive) * The (unbounded in rows) Range \&quot;A:A\&quot; will select all data in column A * The (unbounded in stop coordinates) Range \&quot;B3:\&quot; will select all data below and to the right of B3 (inclusive)  If no region is provided, all data in the sheet will be selected. 
 * @param page The page of results to return. 
 * @param perPage The number of items to return per page. Leave blank for no limit, returning all results. 
 * @return *RangeDataResponse
 */
func (a SpreadsheetsApi) SpreadsheetsSpreadsheetIdSheetsSheetIdDataGet(spreadsheetId string, sheetId string, xApiKey string, revision int32, region string, page int32, perPage int32) (*RangeDataResponse, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/spreadsheets/{SpreadsheetId}/sheets/{SheetId}/data"
	path = strings.Replace(path, "{"+"SpreadsheetId"+"}", fmt.Sprintf("%v", spreadsheetId), -1)
	path = strings.Replace(path, "{"+"SheetId"+"}", fmt.Sprintf("%v", sheetId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(oauth)' required
	// oauth required
	if a.Configuration.AccessToken != ""{
		headerParams["Authorization"] =  "Bearer " + a.Configuration.AccessToken
	}
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("revision", a.Configuration.APIClient.ParameterToString(revision, ""))
			queryParams.Add("region", a.Configuration.APIClient.ParameterToString(region, ""))
			queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
			queryParams.Add("per_page", a.Configuration.APIClient.ParameterToString(perPage, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Api-Key"
	headerParams["X-Api-Key"] = xApiKey

	var successPayload = new(RangeDataResponse)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Writes data in a Region
 * Overwrites all data in a region with new data. If the provided RangeData is smaller than the specified Region, all cells in the Region and not covered by the RangeData will be cleared. The provided RangeData must not be larger than the specified Region. An empty RangeData is valid and may be used to clear a Region.&#39; 
 *
 * @param spreadsheetId A unique identifier for a spreadsheet
 * @param sheetId A unique identifier for a sheet within a spreadsheet
 * @param rangeDataBodyParameter Multidimensional array of cell values in row-major order. The &#x60;null&#x60; JSON value may be used to avoid modifying a cell.
 * @param xApiKey API callers are identified by API keys. Throttling and request quota limits are set for each individual API key.  
 * @param region A1 style representation of a Cell or Range. The Range may be unbounded in  any/all directions.  For example: * The (entirely bounded) Range \&quot;A2:D8\&quot; will select all data in the Range between A2 and D8 (inclusive) * The (unbounded in rows) Range \&quot;A:A\&quot; will select all data in column A * The (unbounded in stop coordinates) Range \&quot;B3:\&quot; will select all data below and to the right of B3 (inclusive)  If no region is provided, all data in the sheet will be selected. 
 * @return *EmptyResponse
 */
func (a SpreadsheetsApi) SpreadsheetsSpreadsheetIdSheetsSheetIdDataPut(spreadsheetId string, sheetId string, rangeDataBodyParameter RangeDataBody, xApiKey string, region string) (*EmptyResponse, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.Configuration.BasePath + "/spreadsheets/{SpreadsheetId}/sheets/{SheetId}/data"
	path = strings.Replace(path, "{"+"SpreadsheetId"+"}", fmt.Sprintf("%v", spreadsheetId), -1)
	path = strings.Replace(path, "{"+"SheetId"+"}", fmt.Sprintf("%v", sheetId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(oauth)' required
	// oauth required
	if a.Configuration.AccessToken != ""{
		headerParams["Authorization"] =  "Bearer " + a.Configuration.AccessToken
	}
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("region", a.Configuration.APIClient.ParameterToString(region, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Api-Key"
	headerParams["X-Api-Key"] = xApiKey

	// body params
	postBody = &rangeDataBodyParameter

	var successPayload = new(EmptyResponse)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Deletes a Sheet.
 * Deletes the identified sheet.
 *
 * @param spreadsheetId A unique identifier for a spreadsheet
 * @param sheetId A unique identifier for a sheet within a spreadsheet
 * @param xApiKey API callers are identified by API keys. Throttling and request quota limits are set for each individual API key.  
 * @return *EmptyResponse
 */
func (a SpreadsheetsApi) SpreadsheetsSpreadsheetIdSheetsSheetIdDelete(spreadsheetId string, sheetId string, xApiKey string) (*EmptyResponse, *APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.Configuration.BasePath + "/spreadsheets/{SpreadsheetId}/sheets/{SheetId}"
	path = strings.Replace(path, "{"+"SpreadsheetId"+"}", fmt.Sprintf("%v", spreadsheetId), -1)
	path = strings.Replace(path, "{"+"SheetId"+"}", fmt.Sprintf("%v", sheetId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(oauth)' required
	// oauth required
	if a.Configuration.AccessToken != ""{
		headerParams["Authorization"] =  "Bearer " + a.Configuration.AccessToken
	}
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Api-Key"
	headerParams["X-Api-Key"] = xApiKey

	var successPayload = new(EmptyResponse)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Retrieve a Sheet
 * Retrieves a sheet from the identified spreadsheet
 *
 * @param spreadsheetId A unique identifier for a spreadsheet
 * @param sheetId A unique identifier for a sheet within a spreadsheet
 * @param xApiKey API callers are identified by API keys. Throttling and request quota limits are set for each individual API key.  
 * @param revision The Spreadsheet revision from which to select data. If no revision is  provided, the latest revision will be selected. 
 * @return *SheetResponse
 */
func (a SpreadsheetsApi) SpreadsheetsSpreadsheetIdSheetsSheetIdGet(spreadsheetId string, sheetId string, xApiKey string, revision int32) (*SheetResponse, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/spreadsheets/{SpreadsheetId}/sheets/{SheetId}"
	path = strings.Replace(path, "{"+"SpreadsheetId"+"}", fmt.Sprintf("%v", spreadsheetId), -1)
	path = strings.Replace(path, "{"+"SheetId"+"}", fmt.Sprintf("%v", sheetId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(oauth)' required
	// oauth required
	if a.Configuration.AccessToken != ""{
		headerParams["Authorization"] =  "Bearer " + a.Configuration.AccessToken
	}
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("revision", a.Configuration.APIClient.ParameterToString(revision, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Api-Key"
	headerParams["X-Api-Key"] = xApiKey

	var successPayload = new(SheetResponse)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Updates a Sheet
 * Updates a Sheet using the given Sheet properties. If any property is  set to the null JSON value or not included in the request the property  will not be modified. 
 *
 * @param spreadsheetId A unique identifier for a spreadsheet
 * @param sheetId A unique identifier for a sheet within a spreadsheet
 * @param sheetBodyParameter Properties for creating a new sheet
 * @param xApiKey API callers are identified by API keys. Throttling and request quota limits are set for each individual API key.  
 * @return *EmptyResponse
 */
func (a SpreadsheetsApi) SpreadsheetsSpreadsheetIdSheetsSheetIdPut(spreadsheetId string, sheetId string, sheetBodyParameter SheetBody, xApiKey string) (*EmptyResponse, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.Configuration.BasePath + "/spreadsheets/{SpreadsheetId}/sheets/{SheetId}"
	path = strings.Replace(path, "{"+"SpreadsheetId"+"}", fmt.Sprintf("%v", spreadsheetId), -1)
	path = strings.Replace(path, "{"+"SheetId"+"}", fmt.Sprintf("%v", sheetId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(oauth)' required
	// oauth required
	if a.Configuration.AccessToken != ""{
		headerParams["Authorization"] =  "Bearer " + a.Configuration.AccessToken
	}
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Api-Key"
	headerParams["X-Api-Key"] = xApiKey

	// body params
	postBody = &sheetBodyParameter

	var successPayload = new(EmptyResponse)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

